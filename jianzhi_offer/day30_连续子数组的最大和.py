# Author: Baozi
#-*- codeing:utf-8 -*-
"""题目描述
HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,
当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},
连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)
"""
"""解题思路：
1.最直观的办法就是枚举出所有的子数组并求出它们的和。一个长度为n的数组，总共有n(n+1)/2个子数组，
但计算出所有的子数组的和，最快也需要O(n^2)的时间。
2.分析数组的规律，例如输入数组为{1，-2,3,10，-4,7,2，-5}，我们从头至尾开始累加实例数组中的每个数字。
初始化和为0。第一步加上第一个数字1，此时和为1.接下来第二步加上数字-2，和就变为-1.我们注意到由于此前
累加的和是-1，小于0，那如果用-1加上3得到的和是2，比3本身还小。因此我们不用考虑从第一个数字开始之前的
子数组，之前累计的和也被抛弃。我们重新从3开始累加，接下来加上10得到和为13，接着加上-4，得到和为9，由于
-4是一个负数，因此累加-4之后的和比原来的小，因此需要将之前得到的13保存下来，它有可能是最大的子数组和。
接下来加7，得到和为16，由于16比13大，将最大的子数组更新为16。接着加上2得到18，继续更新最大子数组和为18，
最后加上-5，得到和为13，小于此前最大的和18，因此对应的最大子数组和为18。
3.利用动态规划法得到其递推式求解。
"""
class Solution:
    def FindGreatestSumOfSubArray(self, array):
        if not array or not isinstance(array,list):
            return 0
        numcur = 0
        numgreat = -float('inf')
        for num in array:
            if numcur <= 0:
                numcur = num
            else:
                numcur += num
            if numcur > numgreat:
                numgreat = numcur
        return numgreat

if __name__ == '__main__':
    a = Solution()
    array = [1, -2, 3, 10, -4, 7, 2, -5]
    result = a.FindGreatestSumOfSubArray(array)
    print(result)